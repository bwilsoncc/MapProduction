# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# convert_to_geodatabase.py
# Created on: 2018-01-10 15:29:52.00000
# Description:
# Convert coverages features to geodatabase feature classes
# ---------------------------------------------------------------------------
from __future__ import print_function
import arcpy
import os, logging
from Toolbox.arc_utilities import aprint, eprint, ListFieldNames, DeleteFC

# ========================================================================

def import_features(coverage, fc, merge):
    """ Import a coverage into a geodatabase feature class.
    The output feature class has to exist. If "merge" = False,
    then delete any existing features first. """

    if not arcpy.Exists(coverage):
        msg = "Input coverage must exist. %s" % coverage
        eprint(msg)
        logging.error(msg)
        return False
    
    if not arcpy.Exists(fc):
        msg = "Output feature class must exist. %s" % fc
        eprint(msg)
        logging.error(msg)
        return False
    
    if not merge:
        try:
            arcpy.DeleteFeatures_management(fc)
        except Exception as e:
            logging.error("import_features(%s,%s) DeleteFeatures :%s" % (coverage,fc, e))

    logging.info("import_features(%s, %s)" % (coverage,fc))
    try:
        arcpy.Append_management(coverage, fc, "NO_TEST")
    except Exception as e:
        logging.error("import_features(%s,%s) Append :%s" % (coverage,fc, e))
        
    return True

def import_all_features(source_folder, geodatabase, merge=False):

    # First item is coverage name, second is featureclass name
    table_xlat = [
        ("corner\\point",     "Corner",                    "MapScale"), #
        ("taxlot\\arc",       "TaxlotsFD\\TaxlotLines",    None),       #
        ("taxlotpt\\point",   "TaxlotsFD\\TaxlotPoints",   None),
#       ("taxlot\\polygon",   "TaxlotsFD\\Taxlot",         None),       # in this scenario polygons are generated by make_polygons

        ("taxcode\\arc",      "TaxlotsFD\\TaxCodeLines",   None),       #
        ("taxcode\\label",    "TaxlotsFD\\TaxCodePoints",  None),       #
#       ("taxcode\\polygon",  "TaxlotsFD\TaxCode",         None),       # in this scenario polygons are generated by make_polygons
        
        ("taxbound\\arc",     "TaxlotsFD\\MapIndexLines",  None),
        ("taxbound\\label",   "TaxlotsFD\\MapIndexPoints", None),
#       ("mapindex\\polygon", "TaxlotsFD\\MapIndex",       "MapScale"), # in this scenario polygons are generated by make_polygons

        ("waterlin\\arc",     "Waterlines",                "MapScale"),
#       ("water\\polygon",    "Water",                     None),       # needed??

        ("cartolin\\arc",     "CartographicLines",         "MapScale"),
        ("refline\\arc",      "ReferenceLines",            "MapScale"),
        ("plssline\\arc",     "PLSSLines",                 "MapScale"),
    ]

    start    = 0
    maxcount = len(table_xlat)
    step     = 1
    
    arcpy.SetProgressor("step", "Importing %d coverages." % maxcount, start, maxcount, step)

    t = 0
    for coverage,fc,fieldname in table_xlat:
        msg = "Importing %s to %s." % (coverage, fc)
        arcpy.SetProgressorLabel(msg)
        t += 1
        #print("%d/%d" % (t, maxcount), msg)

        srccvg = os.path.join(source_folder, coverage)        
        destfc = os.path.join(geodatabase, fc)

        aprint("Importing %s to %s." % (coverage,fc))
        import_features(srccvg, destfc, merge)
            
        arcpy.SetProgressorPosition(t)

    return True

def make_polygons(infc, labelfc, outfc):

    # Notes on "FeatureToPolygon"
    # If you use the "NO ATTRIBUTES" default, then only the shapes are move from the input to the generated polygon feature class.
    # If you use "ATTRIBUTES" the attributes are copied.
    # If you use "ATTRIBUTES" and a polygon or line feature class AND point feature class,
    #   the attributes from the points are copied to the output (the poly/line attributes are lost). 
    # If there are multiple points inside a new polygon feature it picks attributes from one randomly. 
    # Input features can be lines or polygons, so you can think of it as a way of just transferring the attributes if you have input polygons.
    # The blank "" arg is a tolerance, if you have sloppy input you can use this to close the polygons.
    #
    # When I ran it as a standalone tool in ArcMap I got a background server error, I had to run it in foreground.

    # I wish that ESRI was a bit more consistent in what DOES and DOES NOT support the workspace environment variable.

    workspace = arcpy.env.workspace
    ofc = os.path.join(workspace, outfc)
    aprint("make_polygons(%s, %s, %s)" % (infc, labelfc, outfc))
    if arcpy.Exists(ofc):
        arcpy.Delete_management(ofc)
    try:
        arcpy.FeatureToPolygon_management(
            os.path.join(workspace, infc), 
            ofc, "", "ATTRIBUTES", 
            os.path.join(workspace, labelfc))
    except Exception as e:
        print(e)

    return

__stdscales = {
          10 :   120,
          20 :   240,
          30 :   360,
          40 :   480,
          50 :   600,
         100 :  1200,
         200 :  2400,
         400 :  4800,
         800 :  9600,
        1000 : 12000,
        2000 : 24000}

def fixmapscale(fc):
    """ Fix the values of a mapscale column, if they are not already correct. 
    Returns number of rows updated. """
    # Since this only changes known ":' scales to relative scales,
    # it can be run over and over and it won't hurt anything.
    
    count = 0

    if not arcpy.Exists(fc) or int(arcpy.GetCount_management(fc).getOutput(0)) == 0:
        logging.debug("fixmapscale(%s) No features" % fc)
        return
    d = arcpy.Describe(fc)
    try:
        if d.featureType != "Simple":
            return 0
    except Exception as e:
        logging.error("fix_mapscale(%s): %s" % (fc,e))
        return 0

    fieldnames = ListFieldNames(fc)
    try:
        i = [s.lower() for s in fieldnames].index('mapscale')
        f = fieldnames[i]
    except ValueError:
        return 0

    logging.info("Recalculating %s in %s." % (f,fc))
    with arcpy.da.UpdateCursor(fc, [f]) as cursor:
        for row in cursor:
            try:
                newscale = __stdscales[row[0]]
                row[0] = newscale
                cursor.updateRow(row)
                count += 1
            except KeyError:
                continue # Probably does not need updating

    logging.debug("fixmapscale(%s): %d rows updated" % (fc, count))
    return count

def fix_mapscales(gdb, fclist=None):
    """ Fix the "mapscale" field in every feature class in a geodatabase.
   Optionally accepts a list of feature classes. """
    saved = arcpy.env.workspace
    arcpy.env.workspace = gdb

    fdlist = arcpy.ListDatasets()
    if fdlist: 
        for fd in fdlist:
            for fc in arcpy.ListFeatureClasses(feature_dataset=fd):
                if fclist and not(fc in fclist):  # Only do the ones in this list
                    continue
                fixmapscale(fc)

    for fc in arcpy.ListFeatureClasses():
        if fclist and not(fc in fclist):  # Only do the ones in this list
            continue
        fixmapscale(fc)

    arcpy.env.workspace = saved
    return

# ========================================================================
        
if __name__ == "__main__":

    workfolder = "C:\\GeoModel\\Clatsop\\Workfolder"
    target = "t8-9"
    
    sourcedir = os.path.join(workfolder, target)
    geodatabase = os.path.join(workfolder, "ORMAP_Clatsop.gdb")

    print("Importing features...")
    import_all_features(sourcedir, geodatabase)

    saved = arcpy.env.workspace
    arcpy.env.workspace = os.path.join(geodatabase,  "TaxlotsFD")
    make_polygons("MapIndexLines", "MapIndexPoints", "MapIndex")
    make_polygons("TaxcodeLines",  "TaxcodePoints",  "Taxcode")
    make_polygons("TaxlotLines",   "TaxlotPoints",   "Taxlot")
    arcpy.env.workspace = saved

    fix_mapscales(geodatabase, fclist=["MapIndex"])
    print("Tests completed.")

# That's all!
