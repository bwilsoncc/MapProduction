# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# convert_to_geodatabase.py
# Created on: 2018-01-10 15:29:52.00000
# Description:
# Convert coverages features to geodatabase feature classes
# ---------------------------------------------------------------------------
from __future__ import print_function
import arcpy
import os, logging
from Toolbox.arc_utilities import aprint, eprint, ListFieldNames, DeleteFC, AddField
from ormapnum import ormapnum
from ormap_utilities import dict_ormapnumbers

# ========================================================================

def import_features(coverage, fc, merge):
    """ Import a coverage into a geodatabase feature class.
    The output feature class has to exist. If "merge" = False,
    then delete any existing features first. """

    logging.info("Importing coverage %s to featureclass %s (merge=%s)" % (coverage,fc,merge))

    if not arcpy.Exists(coverage):
        msg = "Input coverage must exist. %s" % coverage
        eprint(msg)
        logging.error(msg)
        return False
    
    if not arcpy.Exists(fc):
        msg = "Output feature class must exist. %s" % fc
        eprint(msg)
        logging.error(msg)
        return False
    
    if not merge:
        try:
            arcpy.DeleteFeatures_management(fc)
        except Exception as e:
            logging.error("import_features(%s,%s) DeleteFeatures :%s" % (coverage,fc, e))

    logging.info("import_features(%s, %s)" % (coverage,fc))
    try:
        arcpy.Append_management(coverage, fc, "NO_TEST")
    except Exception as e:
        logging.error("import_features(%s,%s) Append :%s" % (coverage,fc, e))
        
    return True

def import_all_features(source_folder, geodatabase, merge=False):

    # First item is coverage name, second is featureclass name
    # DON'T forget, attributes won't be in the output featureclass unless they are in the template database.

    table_xlat = [
        ("corner\\point",     "Corner",                    "MapScale"), #
        ("taxlot\\arc",       "TaxlotsFD\\TaxlotLines",    None),       #
        ("taxlotpt\\point",   "TaxlotsFD\\TaxlotPoints",   None),
#       ("taxlot\\polygon",   "TaxlotsFD\\Taxlot",         None),       # in this scenario polygons are generated by make_polygons

        ("taxcode\\arc",      "TaxlotsFD\\TaxCodeLines",   None),       # moved to make_polygons!
        ("taxcode\\label",    "TaxlotsFD\\TaxCodePoints",  None),       #
#       ("taxcode\\polygon",  "TaxlotsFD\TaxCode",         None),       # in this scenario polygons are generated by make_polygons
        
        ("taxbound\\arc",     "TaxlotsFD\\MapIndexLines",  None),
        ("mapindex\\label",   "TaxlotsFD\\MapIndexPoints", None),
#       ("mapindex\\polygon", "TaxlotsFD\\MapIndex",       "MapScale"), # in this scenario polygons are generated by make_polygons

        ("waterlin\\arc",     "Waterlines",                "MapScale"),
#       ("water\\polygon",    "Water",                     None),       # needed??

        ("cartolin\\arc",     "CartographicLines",         "MapScale"),
        ("refline\\arc",      "ReferenceLines",            "MapScale"),
        ("plssline\\arc",     "PLSSLines",                 "MapScale"),
    ]

    start    = 0
    maxcount = len(table_xlat)
    step     = 1
    
    t = 0
    for coverage,fc,fieldname in table_xlat:
        t += 1

        srccvg = os.path.join(source_folder, coverage)        
        destfc = os.path.join(geodatabase, fc)

        import_features(srccvg, destfc, merge)
            
    return True

def make_polygons(infc, labelfc, outfc):
    """ Create polygons from a feature class.
    infc      input feature class (can be lines or polygons)
    labelfc   point feature class containing attributes for outfc
    outfc     where to write polygons """

    # Notes on "FeatureToPolygon"
    # If you use the "NO ATTRIBUTES" default, then only the shapes are move from the input to the generated polygon feature class.
    # If you use "ATTRIBUTES" the attributes are copied.
    # If you use "ATTRIBUTES" and a polygon or line feature class AND a point feature class,
    #   the attributes from the points are copied to the output (the poly/line attributes are lost). 
    # If there are multiple points inside a new polygon feature it picks attributes from one randomly. 
    # Input features can be lines or polygons, so you can think of it as a way of just transferring the attributes if you have input polygons.
    # The blank "" arg is a tolerance, if you have sloppy input you can use this to close the polygons.
    #
    # NB when I ran it as a standalone tool in ArcMap I got a background server error, I had to run it in foreground.

    # I wish that ESRI was a bit more consistent in what DOES and DOES NOT support the workspace environment variable.

    workspace = arcpy.env.workspace
    ofc = os.path.join(workspace, outfc)
    aprint("make_polygons(%s, %s, %s)" % (infc, labelfc, outfc))
    if arcpy.Exists(ofc):
        arcpy.Delete_management(ofc)
    try:
        arcpy.FeatureToPolygon_management(
            os.path.join(workspace, infc), 
            ofc, "", "ATTRIBUTES", 
            os.path.join(workspace, labelfc))
    except Exception as e:
        print(e)

    return

def update_mapindex(fc):
    """ Update the mapindex fc by adding and populating fields.
    pagename      a unique page name to identify the row including MapNumber and detail page number
    pagenumber    a long that is properly sorted by pagename
    longmaptitle  a string that can be used on maps as the "small map title"
    """
    fields = ["ORMapNum", "longmaptitle", "OID@"]
    ORMAPNUM = 0
    LONGTTL  = 1
    OID      = 2
    mapindexfc = "MapIndex"
    if arcpy.Exists(mapindexfc):
        AddField(mapindexfc, "LongMapTitle", "TEXT", fieldlen=50)

        orm = ormapnum()

        # Get page numbers
        #d_pagenum = dict_ormapnumbers(fc, "OrMapNum")

        with arcpy.da.UpdateCursor(fc, fields) as cursor:
            for row in cursor:
                oid = row[OID]
                o   = row[ORMAPNUM]
                if not o:
                    logging.debug("Deleting empty feature %d in %s" % (oid, fc))
                    cursor.deleteRow()
                else:
                    try:
                        orm.unpack(o)
                        row[LONGTTL]  = orm.longmaptitle()
                    except ValueError as e:
                        logging.warn(e)

                    cursor.updateRow(row)

    return

__stdscales = {
          10 :   120,
          20 :   240,
          30 :   360,
          40 :   480,
          50 :   600,
          60 :   720, 
         100 :  1200,
         200 :  2400,
         400 :  4800,
         800 :  9600,
        1000 : 12000,
        2000 : 24000}

def fixmapacres(workfolder):
    """ The field mapacres needs to be filled in with acres, I don't know why exactly. """
    fc  = os.path.join(workfolder, "taxlot")
    arcpy.CalculateField_management(fc, "MAPACRES", "!SHAPE.AREA@ACRES!", "PYTHON")
    return

def fixmapscale(fc):
    """ Fix the values of a mapscale column, if they are not already correct. 
    Returns number of rows updated. """
    # Since this only changes known ":' scales to relative scales,
    # it can be run over and over and it won't hurt anything.
    
    count = 0

    if not arcpy.Exists(fc) or int(arcpy.GetCount_management(fc).getOutput(0)) == 0:
        logging.debug("fixmapscale(%s) No features" % fc)
        return
    d = arcpy.Describe(fc)
    try:
        if d.featureType != "Simple":
            return 0
    except Exception as e:
        logging.error("fix_mapscale(%s): %s" % (fc,e))
        return 0

    fieldnames = ListFieldNames(fc)
    try:
        i = [s.lower() for s in fieldnames].index('mapscale')
        f = fieldnames[i]
    except ValueError:
        return 0

    logging.info("Recalculating %s in %s." % (f,fc))
    with arcpy.da.UpdateCursor(fc, [f]) as cursor:
        for row in cursor:
            try:
                newscale = __stdscales[row[0]]
                row[0] = newscale
                cursor.updateRow(row)
                count += 1
            except KeyError:
                continue # Probably does not need updating

    logging.debug("fixmapscale(%s): %d rows updated" % (fc, count))
    return count

def fix_mapscales(gdb, fclist=None):
    """ Fix the "mapscale" field in every feature class in a geodatabase.
   Optionally accepts a list of feature classes. """
    saved = arcpy.env.workspace
    arcpy.env.workspace = gdb

    fdlist = arcpy.ListDatasets()
    if fdlist: 
        for fd in fdlist:
            for fc in arcpy.ListFeatureClasses(feature_dataset=fd):
                if fclist and not(fc in fclist):  # Only do the ones in this list
                    continue
                fixmapscale(fc)

    for fc in arcpy.ListFeatureClasses():
        if fclist and not(fc in fclist):  # Only do the ones in this list
            continue
        fixmapscale(fc)

    arcpy.env.workspace = saved
    return

# ========================================================================
        
if __name__ == "__main__":

    workfolder = "C:\\GeoModel\\Clatsop\\Workfolder"
    target = "t6-10"
    
    sourcedir = os.path.join(workfolder, target)
    geodatabase = os.path.join(workfolder, "ORMAP_Clatsop.gdb")

    #print("Importing features...")
    #import_all_features(sourcedir, geodatabase)

    saved = arcpy.env.workspace
    arcpy.env.workspace = os.path.join(geodatabase, "TaxlotsFD")
    make_polygons("MapIndexLines", "MapIndexPoints", "MapIndex")
    make_polygons("TaxcodeLines",  "TaxcodePoints",  "Taxcode")
    make_polygons("TaxlotLines",   "TaxlotPoints",   "Taxlot")
    make_polygons("TaxlotLines",   "TaxlotPoints",   "Taxlot")

    update_mapindex("MapIndex")
    arcpy.env.workspace = saved

    fix_mapscales(geodatabase, fclist=["MapIndex"])
    print("Tests completed.")

# That's all!
